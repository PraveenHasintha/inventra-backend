// This file defines database tables (Prisma schema).
// We start with User + Role so login works first.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum Role {
  MANAGER
  EMPLOYEE
}

model User {
  id           String   @id @default(uuid())
  name         String
  email        String   @unique
  passwordHash String
  role         Role
  photoUrl     String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  stockTxns    StockTxn[]
  invoices     Invoice[]
}

model Branch {
  id         String   @id @default(uuid())
  name       String
  address    String?
  phone      String?
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  stockItems StockItem[]
  stockTxns  StockTxn[]
  invoices   Invoice[]
}

/**
 * Categories support sub-categories (parentId).
 * Example: Stationery -> Pens
 */
model Category {
  id        String     @id @default(uuid())
  name      String
  parentId  String?
  parent    Category?  @relation("CategoryParentChild", fields: [parentId], references: [id])
  children  Category[] @relation("CategoryParentChild")
  products  Product[]
  isActive  Boolean    @default(true)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@unique([parentId, name])
}

model Product {
  id           String    @id @default(uuid())
  name         String
  description  String?
  sku          String    @unique
  barcode      String?   @unique
  unit         String    @default("PCS")

  // Prices stored as whole rupees (simple for now)
  costPrice    Int
  sellingPrice Int

  categoryId   String?
  category     Category? @relation(fields: [categoryId], references: [id])

  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  stockItems   StockItem[]
  stockTxns    StockTxn[]
  invoiceItems InvoiceItem[]
}

enum StockTxnType {
  RECEIVE
  SALE
  ADJUST
  DAMAGE
}

/**
 * StockItem = current stock quantity for (branch + product)
 */
model StockItem {
  id        String   @id @default(uuid())
  branchId  String
  productId String
  quantity  Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branch    Branch   @relation(fields: [branchId], references: [id])
  product   Product  @relation(fields: [productId], references: [id])

  @@unique([branchId, productId])
}

/**
 * StockTxn = history of stock changes (audit trail)
 * qtyChange: + for receive, - for sale/damage, +/- for adjust
 */
model StockTxn {
  id          String       @id @default(uuid())
  type        StockTxnType
  branchId    String
  productId   String
  qtyChange   Int
  note        String?
  createdAt   DateTime     @default(now())

  branch      Branch       @relation(fields: [branchId], references: [id])
  product     Product      @relation(fields: [productId], references: [id])

  createdById String
  createdBy   User         @relation(fields: [createdById], references: [id])
}

/**
 * Invoice = a completed sale record (professional invoice number like INV-000001)
 *
 * NOTE: We use an auto-increment Int ID for sequencing.
 * invoiceNo is generated from that ID (INV-000001, INV-000002, ...).
 */
model Invoice {
  id          Int          @id @default(autoincrement())
  publicId    String       @unique @default(uuid())

  // âœ… Create first, then update with INV-000001 after we know invoice.id
  invoiceNo   String?      @unique

  branchId    String
  branch      Branch       @relation(fields: [branchId], references: [id])

  createdById String
  createdBy   User         @relation(fields: [createdById], references: [id])

  note        String?
  total       Int          @default(0)
  createdAt   DateTime     @default(now())

  items       InvoiceItem[]
}

model InvoiceItem {
  id         Int      @id @default(autoincrement())

  invoiceId  Int
  invoice    Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  productId  String
  product    Product  @relation(fields: [productId], references: [id])

  qty        Int
  unitPrice  Int
  lineTotal  Int
}
